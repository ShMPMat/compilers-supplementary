-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun bin (l, op, r) {
  Binop (op, l, r) 
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
      exp = memo $ eta (expr (
        {
          [Left, {[s("!!"), bin], [s("&&"), bin]}],
          [Left, {[s("<"),  bin], [s(">"),  bin], [s("<="), bin], [s(">="), bin], [s("=="), bin], [s("!="), bin]}],
          [Left, {[s("+"),  bin], [s("-"),  bin]}],
          [Left, {[s("*"),  bin], [s("/"),  bin], [s("%"),  bin]}]
        },
        primary
      ));

--var stmt = memo $ eta (syntax (
 -- cur = line s[";"] next = stmt {Seq (cur, next)} |
--  r   = line                    { r }
--)),
--      line = memo $ eta (syntax (
--        s["read"]  v = inbr[s("("), lident, s(")")] {Read(v)}    |
--        s["write"] e = inbr[s("("), exp, s(")")]    {Write(e)}   |
--        v = lident s[":="] x = exp                  {Assn(v, x)} |
--        s["skip"]                                   {Skip}                 
--      ));

var stmt = memo $ eta (syntax (
  cur = line s[";"] next = stmt {Seq (cur, next)} |
  r   = line                    { r }
)),
  line = memo $ eta syntax (
    kRead  v = inbr[s("("), lident, s(")")] { Read (v) }    |
    kWrite e = inbr[s("("), exp, s(")")]    { Write (e) }   |
    v = lident s[":="] e = exp              { Assn (v, e) } |
    kSkip                                   { Skip }        |
    c = ifcl                                { c }           | 
    c = whilecl                             { c }
  ),
  ifcl = memo $ eta syntax (
    kIf e = exp kThen s1 = stmt s2 = elsecl { If (e, s1, s2) }
  ),
  elsecl = memo $ eta syntax (
    kFi                                     { Skip }         |
    kElse s = stmt kFi                      { s }            |
    kElif e = exp kThen t = stmt f = elsecl { If (e, t, f) }
  ),
  whilecl = memo $ eta syntax (
    kWhile e = exp  kDo    s = stmt kOd                             { While (e, s) }                  |
    kDo    s = stmt kWhile e = exp  kOd                             { DoWhile (s, e) }                |
    kFor   a = stmt s[","] e = exp s[","] u = stmt kDo s = stmt kOd { Seq (a, While (e, Seq (s, u)))}
  );
   

-- Public top-level parser
public parse = stmt;
